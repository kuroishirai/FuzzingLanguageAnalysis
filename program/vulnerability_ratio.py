#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
RQ2_Vulnerability_Ratio.py
Refactored for replication package (Docker compatible, relative paths, DB connection).
Performs vulnerability ratio analysis across languages using Kruskal–Wallis and
Mann–Whitney tests (Holm correction).
"""

from pathlib import Path
import os
import sys
import traceback
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import matplotlib.colors as mcolors
from scipy import stats
from statsmodels.stats.multitest import multipletests
from configparser import ConfigParser

# ==============================================================================
# Path and Configuration
# ==============================================================================
BASE_DIR = Path(__file__).resolve().parent
DATA_DIR = BASE_DIR.parent / "data" / "RQ2_Vulnerability_Ratio"
DATA_DIR.mkdir(parents=True, exist_ok=True)

# Relative path to config file (e.g., program/config/envFile.ini)
CONFIG_PATH = BASE_DIR.parent / "__module" / "envFile.ini"

# ==============================================================================
# Import custom DB module
# ==============================================================================
sys.path.append(str(BASE_DIR.parent / "__module"))
try:
    import utils
    from dbFile import DB
except Exception as e:
    print("[ERROR] Failed to import DB modules.")
    print(e)
    sys.exit(1)

# ==============================================================================
# Data Fetching from Database
# ==============================================================================
def fetch_data(db):
    """Fetch data directly from PostgreSQL database."""
    query = r"""
WITH project_counts AS (
    SELECT project
    FROM issue_report
    WHERE build_type IS NULL
      AND status ILIKE '%fix%'
    GROUP BY project
    HAVING COUNT(*) >= 10
)
SELECT
    ir.project,
    ir.type,
    pi.language
FROM
    issue_report ir
JOIN
    project_info pi ON ir.project = pi.project
JOIN
    project_counts pc ON ir.project = pc.project
WHERE
    ir.build_type IS NULL
    AND ir.status ILIKE '%fix%'
    AND pi.language NOT IN ('swift', 'javascript');
"""
    df = pd.DataFrame(db.executeDict(query))
    print(f"[INFO] Retrieved {len(df)} rows from DB.")

    # ✅ 修正ポイント：DataFrameが空か確認
    if df.empty:
        print("[WARN] No data retrieved from query.")
        return pd.DataFrame()

    return df


# ==============================================================================
# Visualization
# ==============================================================================
def create_violin_boxplot(df: pd.DataFrame, output_path: Path):
    """Create violin + box plot for vulnerability ratio per language."""
    def lighten_color(c, f=0.6):
        r, g, b, _ = mcolors.to_rgba(c)
        r = 1 - (1 - r) * f
        g = 1 - (1 - g) * f
        b = 1 - (1 - b) * f
        return (r, g, b, 1.0)

    # Compute vulnerability ratio per project-language
    project_vuln_ratio = (
        df.groupby(["project", "language"])["type"]
          .apply(lambda x: (x.str.lower() == "vulnerability").sum() / len(x))
          .reset_index(name="vulnerability_ratio")
    )
    project_vuln_ratio["vulnerability_ratio"] *= 100

    fig, ax = plt.subplots(figsize=(6.5, 4))
    languages = sorted(project_vuln_ratio["language"].unique())

    base_colors = {
        "c": "#1f77b4",
        "c++": "#ff7f0e",
        "go": "#bcbd22",
        "java": "#8c564b",
        "python": "#9467bd",
        "rust": "#2ca02c",
    }
    base_palette = {lang: base_colors.get(lang, "#cccccc") for lang in languages}
    light_palette = {lang: lighten_color(base_palette[lang]) for lang in languages}

    sns.violinplot(
        x="language", y="vulnerability_ratio", data=project_vuln_ratio,
        ax=ax, inner=None, palette=base_palette, order=languages, cut=0
    )

    for lang in languages:
        lang_data = project_vuln_ratio[project_vuln_ratio["language"] == lang]
        sns.boxplot(
            x="language", y="vulnerability_ratio", data=lang_data, ax=ax,
            order=languages, width=0.3,
            showfliers=True,  # ✅ outlierを表示
            boxprops={"facecolor": light_palette[lang], "edgecolor": "#333333"},
            whiskerprops={"color": "#333333"}, capprops={"color": "#333333"},
            medianprops={"color": "#333333"}
        )

    counts = project_vuln_ratio.groupby("language")["project"].nunique()
    new_labels = [f"{lang}\n(n={counts[lang]})" for lang in languages]
    ax.set_xticks(ax.get_xticks(), new_labels)

    ax.set_ylim(-5, 105)
    ax.set_yticks(np.arange(0, 110, 10))
    ax.set_ylabel("Proportion of Vulnerabilities per Project (%)", fontsize=12)
    ax.set_xlabel("", fontsize=12)
    ax.tick_params(axis="x", rotation=0, labelsize=12)
    ax.tick_params(axis="y", labelsize=12)
    ax.grid(axis="y", linestyle=":", color="lightgray")
    plt.tight_layout(pad=0.2)

    output_file = output_path / "03_vulnerability_ratio_distribution.pdf"
    plt.savefig(output_file, format="pdf", bbox_inches="tight")
    plt.close(fig)
    print(f"[INFO] Saved: {output_file}")
    return project_vuln_ratio

# ==============================================================================
# Statistical Analysis
# ==============================================================================
def run_kw_mw_tests(df: pd.DataFrame, alpha: float = 0.05):
    """Run Kruskal–Wallis and Mann–Whitney tests with Holm correction."""
    groups = [g["vulnerability_ratio"] for _, g in df.groupby("language")]
    kw_stat, kw_p = stats.kruskal(*groups)
    kw_result = {"statistic": kw_stat, "pvalue": kw_p}

    langs = sorted(df["language"].unique())
    rows = []
    for i in range(len(langs)):
        for j in range(i + 1, len(langs)):
            la, lb = langs[i], langs[j]
            xa = df.loc[df["language"] == la, "vulnerability_ratio"]
            xb = df.loc[df["language"] == lb, "vulnerability_ratio"]
            if len(xa) < 2 or len(xb) < 2:
                rows.append({"lang_a": la, "lang_b": lb, "pvalue": np.nan})
                continue
            _, p = stats.mannwhitneyu(xa, xb, alternative="two-sided")
            rows.append({"lang_a": la, "lang_b": lb, "pvalue": p})
    pairwise_df = pd.DataFrame(rows)
    mask = pairwise_df["pvalue"].notna()
    _, p_adj, _, _ = multipletests(pairwise_df.loc[mask, "pvalue"], alpha=alpha, method="holm")
    pairwise_df.loc[mask, "pvalue_holm"] = p_adj
    return kw_result, pairwise_df

def save_results(project_vuln_ratio, kw_result, pairwise_df):
    """Save Kruskal–Wallis and Mann–Whitney results and figures."""
    # Save KW result
    kw_path = DATA_DIR / "kruskal_result.csv"
    pd.DataFrame([kw_result]).to_csv(kw_path, index=False)
    print(f"[INFO] Saved: {kw_path}")

    # Save summary stats
    summary = project_vuln_ratio.groupby("language")["vulnerability_ratio"].agg(
        n="count", mean="mean", median="median", std="std", min="min", max="max"
    ).reset_index()
    summary_path = DATA_DIR / "language_summary_stats.csv"
    summary.to_csv(summary_path, index=False)
    print(f"[INFO] Saved: {summary_path}")

    # Save Holm-adjusted heatmap
    langs = sorted(set(pairwise_df["lang_a"]).union(pairwise_df["lang_b"]))
    matrix = pd.DataFrame(1.0, index=langs, columns=langs)
    for _, r in pairwise_df.iterrows():
        a, b, p = r["lang_a"], r["lang_b"], r.get("pvalue_holm", np.nan)
        if not pd.isna(p):
            matrix.loc[a, b] = matrix.loc[b, a] = p
    np.fill_diagonal(matrix.values, 0.0)

    fig, ax = plt.subplots(figsize=(6.5, 4))

    # ✅ 上三角をマスクして下三角ヒートマップにする
    mask = np.triu(np.ones_like(matrix, dtype=bool))

    sns.heatmap(
        matrix,
        cmap="coolwarm_r",
        annot=True,
        fmt=".3f",
        linewidths=0.3,
        cbar_kws={"label": "Holm-adjusted p-value"},
        ax=ax,
        square=False,
        mask=mask,  # ✅ 追加
        vmin=0,   # ✅ カラースケールの最小値
        vmax=1    # ✅ カラースケールの最大値
    )
    ax.set_title("Pairwise Mann–Whitney (Holm-adjusted p-values)")
    ax.set_xlabel("Language")
    ax.set_ylabel("Language")
    plt.tight_layout(pad=0.2)
    heatmap_path = DATA_DIR / "pairwise_tests_summary_heatmaps_all.pdf"
    plt.savefig(heatmap_path, format="pdf", bbox_inches="tight")
    plt.close(fig)
    print(f"[INFO] Saved: {heatmap_path}")

# ==============================================================================
# Main
# ==============================================================================
def main():
    """Main entry point."""
    start_time = utils.return_now_datetime_jst()
    db = utils.setup_db(CONFIG_PATH)
    db.connect()
    try:
        df_raw = fetch_data(db)
        if df_raw.empty:
            print("[WARN] No data retrieved. Exiting.")
            return
        df_raw["language"] = df_raw["language"].replace({"jvm": "java"})

        project_vuln_ratio = create_violin_boxplot(df_raw, DATA_DIR)
        kw_result, pairwise_df = run_kw_mw_tests(project_vuln_ratio)
        save_results(project_vuln_ratio, kw_result, pairwise_df)

        print("✅ Completed RQ2 Vulnerability Ratio analysis.")
    except Exception as e:
        print(f"[ERROR] {e}")
        traceback.print_exc()
    finally:
        db.close()

if __name__ == "__main__":
    main()
